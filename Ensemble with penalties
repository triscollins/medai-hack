# =========================================================
# 3. Ensemble with penalties
# =========================================================


from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, make_scorer
from sklearn.utils.class_weight import compute_class_weight
import numpy as np

def weighted_accuracy_score(y_true, y_pred, class_penalties):
    """
    Custom scoring function that applies penalties for incorrect predictions
    based on class importance
    
    Parameters:
    y_true: True labels
    y_pred: Predicted labels
    class_penalties: Dictionary mapping class labels to their penalty weights
    """
    correct = (y_true == y_pred)
    weights = np.array([class_penalties[label] for label in y_true])
    return np.sum(correct * weights) / np.sum(weights)

# Compute class weights based on frequency
unique_classes = np.unique(y_train)
class_weights = compute_class_weight(
    class_weight='balanced',
    classes=unique_classes,
    y=y_train
)

# Create penalty dictionary (higher penalty for underrepresented classes)
class_penalties = dict(zip(unique_classes, class_weights))

# Create custom scorer
weighted_scorer = make_scorer(
    weighted_accuracy_score,
    class_penalties=class_penalties
)

# Create base models
knn_model = KNeighborsClassifier(
    n_neighbors=5,
    weights='distance'  # Weight points by distance
)

rf_model = RandomForestClassifier(
    class_weight='balanced',  # For imbalanced dataset
    n_estimators=10,
    random_state=42
)

# Create voting classifier
ensemble = VotingClassifier(
    estimators=[
        ('knn', knn_model),
        ('rf', rf_model)
    ],
    voting='soft'  # Use probability predictions
)

# Fit the ensemble with sample weights
sample_weights = np.array([class_penalties[label] for label in y_train])
ensemble.fit(X_train_scaled, y_train, sample_weight=sample_weights)



# Make predictions
ensemble_predictions = ensemble.predict(X_test_scaled)

# Print weighted and unweighted accuracy
print("Standard Accuracy:", accuracy_score(y_test, ensemble_predictions))
print("Weighted Accuracy:", weighted_accuracy_score(y_test, ensemble_predictions, class_penalties))



# =========================================================
# 3. Predictions on submission data
# =========================================================


# Make predictions using the penalty-weighted ensemble
submission_predictions = ensemble.predict(submission_scaled)

# Create submission DataFrame
predictions_df = pd.DataFrame({
    'ID': submission_df['ID'],
    'predicted_label': submission_predictions
})

# Save predictions to CSV
output_file = 'predictions_weighted_ensemble.csv'
predictions_df.to_csv(output_file, index=False)

# Display download link
FileLink(output_file)
